rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ===== Helper Functions =====
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Check if the authenticated user is a member of the given organisation.
    // Relies on custom claims set by the onMembershipChange Cloud Function.
    // Claims structure: { orgs: { "orgId": { p: [...], b: [...] } } }
    function isOrgMember(orgId) {
      return isSignedIn()
        && request.auth.token.orgs != null
        && orgId in request.auth.token.orgs;
    }

    // Check if the user has a specific abbreviated permission in the given org.
    // Owner claims contain "*" (wildcard) which grants all permissions.
    // Permission abbreviations are defined in functions/src/claims.ts.
    function hasOrgPermission(orgId, abbrevPermission) {
      return isOrgMember(orgId)
        && ('*' in request.auth.token.orgs[orgId].p
            || abbrevPermission in request.auth.token.orgs[orgId].p);
    }

    // ===== Users Collection =====
    // Users can read any user profile (needed for team member listings).
    // Users can create their own profile on first sign-in.
    // Users can update ONLY safe profile fields on their own document.
    // claimsVersion is protected â€” only Cloud Functions (Admin SDK) can change it.
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.authProvider == resource.data.authProvider
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.claimsVersion == resource.data.claimsVersion;
      allow delete: if false;
    }

    // ===== Organizations Collection =====
    // Only organisation members can read their own org document.
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /organizations/{organizationId} {
      allow read: if isOrgMember(organizationId);
      allow write: if false;
    }

    // ===== Organization Members Collection =====
    // Readable by:
    //   (a) the member themselves (needed for bootstrap: getUserOrganizations
    //       queries by userId to discover which orgs the user belongs to,
    //       before any org-specific claims are available), OR
    //   (b) fellow org members (for team listings; client queries MUST include
    //       .where('organizationId', '==', orgId) so Firestore can verify
    //       the constraint against claims).
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /organizationMembers/{memberId} {
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.userId
        || isOrgMember(resource.data.organizationId)
      );
      allow write: if false;
    }

    // ===== Brands Collection =====
    // Get (single doc): Org members OR anyone if brand is active (for audience app styling)
    // List (queries): Org members only (for creator app brand management)
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /brands/{brandId} {
      allow get: if isOrgMember(resource.data.organizationId)
                 || resource.data.isActive == true;
      allow list: if isOrgMember(resource.data.organizationId);
      allow write: if false;
    }

    // ===== Invitations Collection =====
    // Readable by:
    //   (a) the invitee (matching email, case-insensitive), OR
    //   (b) an org member with the users:invite permission (abbreviated 'ui').
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /invitations/{invitationId} {
      allow read: if isSignedIn() && (
        request.auth.token.email.lower() == resource.data.email.lower()
        || hasOrgPermission(resource.data.organizationId, 'ui')
      );
      allow write: if false;
    }

    // ===== Events Collection =====
    // Get (single doc): Org members OR anyone if event is active
    // List (queries): Anyone (for child event discovery, filtered client-side)
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /events/{eventId} {
      allow get: if isOrgMember(resource.data.organizationId)
                 || resource.data.isActive == true;
      allow list: if true; // Public queries for audience to discover child events
      allow write: if false;
    }

    // ===== QR Codes Collection =====
    // Get (single doc): Org members OR anyone if QR code is active  
    // List (queries): Org members only (creator app needs to list QR codes for management)
    // All writes go through server-side API routes (Firebase Admin SDK).
    match /qrCodes/{qrCodeId} {
      allow get: if isOrgMember(resource.data.organizationId)
                 || resource.data.isActive == true;
      allow list: if isOrgMember(resource.data.organizationId);
      allow write: if false;
    }

    // ===== Audience Sessions Collection =====
    // Tracks audience member sessions for billing and analytics.
    // All writes go through server-side API routes (Firebase Admin SDK).
    // Org members can read sessions for their events (analytics).
    match /audienceSessions/{sessionId} {
      allow read: if isOrgMember(resource.data.organizationId);
      allow write: if false;
    }

    // ===== Organization Deletion Requests =====
    // Server-side only (created by deletion API routes).
    match /organizationDeletionRequests/{requestId} {
      allow read: if false;
      allow write: if false;
    }

    // ===== Email Queue =====
    // Queue-based email delivery system.
    // Users can create pending emails (triggers Cloud Function processing).
    // Only Cloud Functions can update status (uses Admin SDK).
    match /emailQueue/{emailId} {
      // Authenticated users can queue emails with valid initial state
      allow create: if request.auth != null
                    && request.resource.data.status == 'pending'
                    && request.resource.data.attempts == 0
                    && request.resource.data.to.matches('^[^@]+@[^@]+\\.[^@]+$');
      
      // Users can read emails they triggered (via metadata.userId)
      allow read: if request.auth != null
                  && request.auth.uid == resource.data.metadata.userId;
      
      // Only Cloud Functions can update (uses Admin SDK, bypasses rules)
      allow update: if false;
      allow delete: if false;
      
      // Rate limit subcollection - server-only
      match /_rateLimits/{scope}/{type} {
        allow read, write: if false;
      }
    }

    // ===== Deleted Organizations Audit =====
    // Server-side only (created by Cloud Functions).
    match /deletedOrganizationsAudit/{auditId} {
      allow read: if false;
      allow write: if false;
    }

    // ===== Default: deny all other access =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}